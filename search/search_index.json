{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-authentication The Zend\\Authentication component provides an API for authentication and includes concrete authentication adapters for common use case scenarios. File issues at https://github.com/zendframework/zend-authentication/issues Documentation is at https://docs.zendframework.com/zend-authentication/","title":"zend-authentication"},{"location":"#zend-authentication","text":"The Zend\\Authentication component provides an API for authentication and includes concrete authentication adapters for common use case scenarios. File issues at https://github.com/zendframework/zend-authentication/issues Documentation is at https://docs.zendframework.com/zend-authentication/","title":"zend-authentication"},{"location":"intro/","text":"Introduction zend-authentication provides an API for authentication and includes concrete authentication adapters for common use case scenarios. zend-authentication is concerned only with authentication and not with authorization . Authentication is loosely defined as determining whether an entity actually is what it purports to be (i.e., identification), based on some set of credentials. Authorization, the process of deciding whether to allow an entity access to, or to perform operations upon, other entities is outside the scope of Zend\\Authentication . For more information about authorization and access control with Zend Framework, please see the zend-permissions-acl or zend-permissions-rbac components. AuthenticationService There is no Zend\\Authentication\\Authentication class; instead the class Zend\\Authentication\\AuthenticationService is provided. This class uses the composed authentication adapter and persistent storage backend. Usage There are two approaches to using zend-authentication adapters: indirectly, through Zend\\Authentication\\AuthenticationService::authenticate() directly, through the adapter's authenticate() method The following example illustrates how to use an adapter indirectly, through the use of the Zend\\Authentication\\AuthenticationService class: use My\\Auth\\Adapter; use Zend\\Authentication\\AuthenticationService; // Instantiate the authentication service: $auth = new AuthenticationService(); // Instantiate the authentication adapter: $authAdapter = new Adapter($username, $password); // Attempt authentication, saving the result: $result = $auth->authenticate($authAdapter); if (! $result->isValid()) { // Authentication failed; print the reasons why: foreach ($result->getMessages() as $message) { echo \"$message\\n\"; } } else { // Authentication succeeded; the identity ($username) is stored // in the session: // $result->getIdentity() === $auth->getIdentity() // $result->getIdentity() === $username } After a successful authentication attempt, subsequent requests can query the authentication service to determine if an identity is present, and, if so, retrieve it: if ($auth->hasIdentity()) { // Identity exists; get it $identity = $auth->getIdentity(); } To remove the identity from persistent storage, use the clearIdentity() method. This typically would be used for implementing an application \"logout\" operation: $auth->clearIdentity(); When the automatic use of persistent storage is inappropriate for a particular use case, a developer may bypass the use of the Zend\\Authentication\\AuthenticationService class, using an adapter class directly. Direct use of an adapter class involves configuring and preparing an adapter object and then calling its authenticate() method. Adapter-specific details are discussed in the documentation for each adapter. The following example directly utilizes the fictional My\\Auth\\Adapter from the above examples: use My\\Auth\\Adapter; // Set up the authentication adapter: $authAdapter = new Adapter($username, $password); // Attempt authentication, saving the result: $result = $authAdapter->authenticate(); if (! $result->isValid()) { // Authentication failed; print the reasons why foreach ($result->getMessages() as $message) { echo \"$message\\n\"; } } else { // Authentication succeeded // $result->getIdentity() === $username }","title":"Intro"},{"location":"intro/#introduction","text":"zend-authentication provides an API for authentication and includes concrete authentication adapters for common use case scenarios. zend-authentication is concerned only with authentication and not with authorization . Authentication is loosely defined as determining whether an entity actually is what it purports to be (i.e., identification), based on some set of credentials. Authorization, the process of deciding whether to allow an entity access to, or to perform operations upon, other entities is outside the scope of Zend\\Authentication . For more information about authorization and access control with Zend Framework, please see the zend-permissions-acl or zend-permissions-rbac components.","title":"Introduction"},{"location":"intro/#authenticationservice","text":"There is no Zend\\Authentication\\Authentication class; instead the class Zend\\Authentication\\AuthenticationService is provided. This class uses the composed authentication adapter and persistent storage backend.","title":"AuthenticationService"},{"location":"intro/#usage","text":"There are two approaches to using zend-authentication adapters: indirectly, through Zend\\Authentication\\AuthenticationService::authenticate() directly, through the adapter's authenticate() method The following example illustrates how to use an adapter indirectly, through the use of the Zend\\Authentication\\AuthenticationService class: use My\\Auth\\Adapter; use Zend\\Authentication\\AuthenticationService; // Instantiate the authentication service: $auth = new AuthenticationService(); // Instantiate the authentication adapter: $authAdapter = new Adapter($username, $password); // Attempt authentication, saving the result: $result = $auth->authenticate($authAdapter); if (! $result->isValid()) { // Authentication failed; print the reasons why: foreach ($result->getMessages() as $message) { echo \"$message\\n\"; } } else { // Authentication succeeded; the identity ($username) is stored // in the session: // $result->getIdentity() === $auth->getIdentity() // $result->getIdentity() === $username } After a successful authentication attempt, subsequent requests can query the authentication service to determine if an identity is present, and, if so, retrieve it: if ($auth->hasIdentity()) { // Identity exists; get it $identity = $auth->getIdentity(); } To remove the identity from persistent storage, use the clearIdentity() method. This typically would be used for implementing an application \"logout\" operation: $auth->clearIdentity(); When the automatic use of persistent storage is inappropriate for a particular use case, a developer may bypass the use of the Zend\\Authentication\\AuthenticationService class, using an adapter class directly. Direct use of an adapter class involves configuring and preparing an adapter object and then calling its authenticate() method. Adapter-specific details are discussed in the documentation for each adapter. The following example directly utilizes the fictional My\\Auth\\Adapter from the above examples: use My\\Auth\\Adapter; // Set up the authentication adapter: $authAdapter = new Adapter($username, $password); // Attempt authentication, saving the result: $result = $authAdapter->authenticate(); if (! $result->isValid()) { // Authentication failed; print the reasons why foreach ($result->getMessages() as $message) { echo \"$message\\n\"; } } else { // Authentication succeeded // $result->getIdentity() === $username }","title":"Usage"},{"location":"storage/","text":"Identity Persistence Authenticating a request that includes authentication credentials is useful, but it is also often useful to persist the authenticated identity between requests, so the user does not need to provide credentials with each request. HTTP is a stateless protocol; however, techniques such as cookies and sessions have been developed in order to facilitate maintaining state across multiple requests in server-side web applications. Default Persistence in the PHP Session By default, zend-authentication provides persistent storage of the identity from a successful authentication attempt using PHP session facilities. Upon a successful authentication attempt, Zend\\Authentication\\AuthenticationService::authenticate() stores the identity from the authentication result into persistent storage. Unless specified otherwise, Zend\\Authentication\\AuthenticationService uses a storage class named Zend\\Authentication\\Storage\\Session , which depends on zend-session . You may also implement Zend\\Authentication\\Storage\\StorageInterface , and provide your implementation to Zend\\Authentication\\AuthenticationService::setStorage() . Bypass the AuthenticationService If automatic persistent storage of the identity is not appropriate for your use case, you can skip usage of Zend\\Authentication\\AuthenticationService altogether, and instead use an adapter directly. Modifying the Session Namespace Zend\\Authentication\\Storage\\Session uses the session namespace Zend_Auth . This namespace may be overridden by passing a different value to the constructor of Zend\\Authentication\\Storage\\Session , and this value is internally passed along to the constructor of Zend\\Session\\Container . This should occur before authentication is attempted, since Zend\\Authentication\\AuthenticationService::authenticate() injects the authenticated identity into the configured storage. use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Storage\\Session as SessionStorage; $auth = new AuthenticationService(); // Use 'someNamespace' instead of 'Zend_Auth' $auth->setStorage(new SessionStorage('someNamespace')); // Set up the auth adapter, $authAdapter $authAdapter = /* ... */; // Authenticate, saving the result, and persisting the identity on success: $result = $auth->authenticate($authAdapter); Chain Storage A website might use multiple storage strategies for identity persistence; the Chain Storage can be used to glue these together. For example, the Chain can be configured to first use Session storage and then use an OAuth storage adapter. One could configure this in the following way: $storage = new Chain; $storage->add(new Session); $storage->add(new OAuth); // Note: imaginary storage, not part of zend-authentication When the Chain Storage is used, its underlying storage adapters will be consulted in the order in which they were added to the chain. Using our scenario above, the Session storage adapter will be consulted first. When that happens: If the Session storage is non-empty, the Chain will use and return its contents. If the Session storage is empty, the Chain will move on to the OAuth storage adapter. If the OAuth storage is empty, the Chain will return an empty result. If the OAuth storage is non-empty, the Chain will use and return its contents. However, it will also populate all storage adapters with higher priority with the contents; in our example, the Session storage will be populated, but if we'd added any adapters after the OAuth adapter, they would not. The priority of storage adapters in the Chain can be made explicit via the Chain::add method, which accepts a second argument indicating the priority. (Per standard priority queue usage, higher values have higher priority, and lower or negative values have lower priority.) $chain->add(new A, 2); $chain->add(new B, 10); // B will be used first Implementing Custom Storage Sometimes developers may need to use a different identity storage mechanism than that provided by Zend\\Authentication\\Storage\\Session . To do so, implement Zend\\Authentication\\Storage\\StorageInterface and supply an instance of your implementation to Zend\\Authentication\\AuthenticationService::setStorage() . The following examples demonstrate the process. First, implement Zend\\Authentication\\Storage\\StorageInterface : <?php namespace My; use Zend\\Authentication\\Storage\\StorageInterface; class Storage implements StorageInterface { /** * Returns true if and only if storage is empty. * * @return boolean * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If it is * impossible to determine whether storage is empty. */ public function isEmpty() { /** * @todo implementation */ } /** * Returns the contents of storage. * * Behavior is undefined when storage is empty. * * @return mixed * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If reading * contents from storage is impossible */ public function read() { /** * @todo implementation */ } /** * Writes $contents to storage. * * @param mixed $contents * @return void * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If writing * $contents to storage is impossible */ public function write($contents) { /** * @todo implementation */ } /** * Clears contents from storage. * * @return void * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If clearing * contents from storage is impossible. */ public function clear() { /** * @todo implementation */ } } In order to use this custom storage class, Zend\\Authentication\\AuthenticationService::setStorage() is invoked before an authentication query is attempted: use My\\Storage; use Zend\\Authentication\\AuthenticationService; // Create the authentication service instance: $auth = new AuthenticationService(); // Instruct the authentication service to use the custom storage class: $auth->setStorage(new Storage()); // Create the authentication adapter: $adapter = /* ... */; // Authenticate, saving the result, and persisting the identity on success: $result = $auth->authenticate($adapter);","title":"Identity Persistence"},{"location":"storage/#identity-persistence","text":"Authenticating a request that includes authentication credentials is useful, but it is also often useful to persist the authenticated identity between requests, so the user does not need to provide credentials with each request. HTTP is a stateless protocol; however, techniques such as cookies and sessions have been developed in order to facilitate maintaining state across multiple requests in server-side web applications.","title":"Identity Persistence"},{"location":"storage/#default-persistence-in-the-php-session","text":"By default, zend-authentication provides persistent storage of the identity from a successful authentication attempt using PHP session facilities. Upon a successful authentication attempt, Zend\\Authentication\\AuthenticationService::authenticate() stores the identity from the authentication result into persistent storage. Unless specified otherwise, Zend\\Authentication\\AuthenticationService uses a storage class named Zend\\Authentication\\Storage\\Session , which depends on zend-session . You may also implement Zend\\Authentication\\Storage\\StorageInterface , and provide your implementation to Zend\\Authentication\\AuthenticationService::setStorage() .","title":"Default Persistence in the PHP Session"},{"location":"storage/#bypass-the-authenticationservice","text":"If automatic persistent storage of the identity is not appropriate for your use case, you can skip usage of Zend\\Authentication\\AuthenticationService altogether, and instead use an adapter directly.","title":"Bypass the AuthenticationService"},{"location":"storage/#modifying-the-session-namespace","text":"Zend\\Authentication\\Storage\\Session uses the session namespace Zend_Auth . This namespace may be overridden by passing a different value to the constructor of Zend\\Authentication\\Storage\\Session , and this value is internally passed along to the constructor of Zend\\Session\\Container . This should occur before authentication is attempted, since Zend\\Authentication\\AuthenticationService::authenticate() injects the authenticated identity into the configured storage. use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Storage\\Session as SessionStorage; $auth = new AuthenticationService(); // Use 'someNamespace' instead of 'Zend_Auth' $auth->setStorage(new SessionStorage('someNamespace')); // Set up the auth adapter, $authAdapter $authAdapter = /* ... */; // Authenticate, saving the result, and persisting the identity on success: $result = $auth->authenticate($authAdapter);","title":"Modifying the Session Namespace"},{"location":"storage/#chain-storage","text":"A website might use multiple storage strategies for identity persistence; the Chain Storage can be used to glue these together. For example, the Chain can be configured to first use Session storage and then use an OAuth storage adapter. One could configure this in the following way: $storage = new Chain; $storage->add(new Session); $storage->add(new OAuth); // Note: imaginary storage, not part of zend-authentication When the Chain Storage is used, its underlying storage adapters will be consulted in the order in which they were added to the chain. Using our scenario above, the Session storage adapter will be consulted first. When that happens: If the Session storage is non-empty, the Chain will use and return its contents. If the Session storage is empty, the Chain will move on to the OAuth storage adapter. If the OAuth storage is empty, the Chain will return an empty result. If the OAuth storage is non-empty, the Chain will use and return its contents. However, it will also populate all storage adapters with higher priority with the contents; in our example, the Session storage will be populated, but if we'd added any adapters after the OAuth adapter, they would not. The priority of storage adapters in the Chain can be made explicit via the Chain::add method, which accepts a second argument indicating the priority. (Per standard priority queue usage, higher values have higher priority, and lower or negative values have lower priority.) $chain->add(new A, 2); $chain->add(new B, 10); // B will be used first","title":"Chain Storage"},{"location":"storage/#implementing-custom-storage","text":"Sometimes developers may need to use a different identity storage mechanism than that provided by Zend\\Authentication\\Storage\\Session . To do so, implement Zend\\Authentication\\Storage\\StorageInterface and supply an instance of your implementation to Zend\\Authentication\\AuthenticationService::setStorage() . The following examples demonstrate the process. First, implement Zend\\Authentication\\Storage\\StorageInterface : <?php namespace My; use Zend\\Authentication\\Storage\\StorageInterface; class Storage implements StorageInterface { /** * Returns true if and only if storage is empty. * * @return boolean * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If it is * impossible to determine whether storage is empty. */ public function isEmpty() { /** * @todo implementation */ } /** * Returns the contents of storage. * * Behavior is undefined when storage is empty. * * @return mixed * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If reading * contents from storage is impossible */ public function read() { /** * @todo implementation */ } /** * Writes $contents to storage. * * @param mixed $contents * @return void * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If writing * $contents to storage is impossible */ public function write($contents) { /** * @todo implementation */ } /** * Clears contents from storage. * * @return void * @throws \\Zend\\Authentication\\Exception\\ExceptionInterface If clearing * contents from storage is impossible. */ public function clear() { /** * @todo implementation */ } } In order to use this custom storage class, Zend\\Authentication\\AuthenticationService::setStorage() is invoked before an authentication query is attempted: use My\\Storage; use Zend\\Authentication\\AuthenticationService; // Create the authentication service instance: $auth = new AuthenticationService(); // Instruct the authentication service to use the custom storage class: $auth->setStorage(new Storage()); // Create the authentication adapter: $adapter = /* ... */; // Authenticate, saving the result, and persisting the identity on success: $result = $auth->authenticate($adapter);","title":"Implementing Custom Storage"},{"location":"validator/","text":"Authentication Validator Zend\\Authentication\\Validator\\Authentication provides a zend-validator ValidatorInterface implementation, which can be used within an input filter or form , or anywhere you you simply want a true/false value to determine whether or not authentication credentials were provided. The available configuration options include: adapter : an instance of Zend\\Authentication\\Adapter\\AdapterInterface . identity : the identity or name of the identity field in the provided context. credential : credential or the name of the credential field in the provided context. service : an instance of Zend\\Authentication\\AuthenticationService . Usage use My\\Authentication\\Adapter; use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Validator\\Authentication as AuthenticationValidator; $service = new AuthenticationService(); $adapter = new Adapter(); $validator = new AuthenticationValidator([ 'service' => $service, 'adapter' => $adapter, ]); $validator->setCredential('myCredentialContext'); $validator->isValid('myIdentity', [ 'myCredentialContext' => 'myCredential', ]);","title":"Validation"},{"location":"validator/#authentication-validator","text":"Zend\\Authentication\\Validator\\Authentication provides a zend-validator ValidatorInterface implementation, which can be used within an input filter or form , or anywhere you you simply want a true/false value to determine whether or not authentication credentials were provided. The available configuration options include: adapter : an instance of Zend\\Authentication\\Adapter\\AdapterInterface . identity : the identity or name of the identity field in the provided context. credential : credential or the name of the credential field in the provided context. service : an instance of Zend\\Authentication\\AuthenticationService .","title":"Authentication Validator"},{"location":"validator/#usage","text":"use My\\Authentication\\Adapter; use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Validator\\Authentication as AuthenticationValidator; $service = new AuthenticationService(); $adapter = new Adapter(); $validator = new AuthenticationValidator([ 'service' => $service, 'adapter' => $adapter, ]); $validator->setCredential('myCredentialContext'); $validator->isValid('myIdentity', [ 'myCredentialContext' => 'myCredential', ]);","title":"Usage"},{"location":"adapter/digest/","text":"Digest Authentication Digest authentication is a method of HTTP authentication that improves upon Basic authentication by providing a way to authenticate without having to transmit the password in clear text across the network. This adapter allows authentication against text files containing lines having the basic elements of Digest authentication: username , such as \"joe.user\"; realm , such as \"Administrative Area\"; an MD5 hash of the username, realm, and password, separated by colons. The above elements are separated by colons, as in the following example (in which the password is \"somePassword\"): someUser:Some Realm:fde17b91c3a510ecbaf7dbd37f59d4f8 Specifics The digest authentication adapter, Zend\\Authentication\\Adapter\\Digest , requires several input parameters: filename : Filename against which authentication queries are performed. realm : Digest authentication realm. username : Digest authentication user. password : Password for the user of the realm. These parameters must be set prior to calling authenticate() . Identity The digest authentication adapter returns a Zend\\Authentication\\Result object populated with the identity as an array containing the keys realm and username . The respective array values associated with these keys correspond to the values set before authenticate() is called. use Zend\\Authentication\\Adapter\\Digest as AuthAdapter; $adapter = new AuthAdapter( $filename, $realm, $username, $password ); $result = $adapter->authenticate(); $identity = $result->getIdentity(); print_r($identity); /* Array ( [realm] => Some Realm [username] => someUser ) */","title":"Digest"},{"location":"adapter/digest/#digest-authentication","text":"Digest authentication is a method of HTTP authentication that improves upon Basic authentication by providing a way to authenticate without having to transmit the password in clear text across the network. This adapter allows authentication against text files containing lines having the basic elements of Digest authentication: username , such as \"joe.user\"; realm , such as \"Administrative Area\"; an MD5 hash of the username, realm, and password, separated by colons. The above elements are separated by colons, as in the following example (in which the password is \"somePassword\"): someUser:Some Realm:fde17b91c3a510ecbaf7dbd37f59d4f8","title":"Digest Authentication"},{"location":"adapter/digest/#specifics","text":"The digest authentication adapter, Zend\\Authentication\\Adapter\\Digest , requires several input parameters: filename : Filename against which authentication queries are performed. realm : Digest authentication realm. username : Digest authentication user. password : Password for the user of the realm. These parameters must be set prior to calling authenticate() .","title":"Specifics"},{"location":"adapter/digest/#identity","text":"The digest authentication adapter returns a Zend\\Authentication\\Result object populated with the identity as an array containing the keys realm and username . The respective array values associated with these keys correspond to the values set before authenticate() is called. use Zend\\Authentication\\Adapter\\Digest as AuthAdapter; $adapter = new AuthAdapter( $filename, $realm, $username, $password ); $result = $adapter->authenticate(); $identity = $result->getIdentity(); print_r($identity); /* Array ( [realm] => Some Realm [username] => someUser ) */","title":"Identity"},{"location":"adapter/http/","text":"HTTP Authentication Adapter Zend\\Authentication\\Adapter\\Http provides a mostly-compliant implementation of RFC-2617 , Basic and Digest HTTP Authentication. Digest authentication is a method of HTTP authentication that improves upon Basic authentication by providing a way to authenticate without having to transmit the password in clear text across the network. Major Features Supports both Basic and Digest authentication. Issues challenges in all supported schemes, so client can respond with any scheme it supports. Supports proxy authentication. Includes support for authenticating against text files and provides an interface for authenticating against other sources, such as databases. There are a few notable features of RFC-2617 that are not implemented yet: Nonce tracking, which would allow for \"stale\" support, and increased replay attack protection. Authentication with integrity checking, or \"auth-int\". Authentication-Info HTTP header. Requirements The HTTP authentication adapter requires zend-http in order to do its work: $ composer require zendframework/zend-http Design Overview This adapter consists of two sub-components, the HTTP authentication class itself, and its \"Resolvers.\" The HTTP authentication class encapsulates the logic for carrying out both Basic and Digest authentication. It consumes Resolvers to look up a client's identity in some data store (text file by default), and retrieve the credentials from the data store. The \"resolved\" credentials are then compared to the values submitted by the client to determine whether authentication is successful. Configuration Options Zend\\Authentication\\Adapter\\Http requires a configuration array passed to its constructor. There are several configuration options available, and some are required: Option Name Required Description accept_schemes Yes Determines which authentication schemes the adapter will accept from the client. Must be a space-separated list containing basic and/or digest . realm Yes Sets the authentication realm; usernames should be unique within a given realm. digest_domains Yes, when accept_schemes contains digest Space-separated list of URIs for which the same authentication information is valid. The URIs need not all point to the same server. nonce_timeout Yes, when accept_schemes contains digest Sets the number of seconds for which the nonce is valid. See notes below. use_opaque No Specifies whether to send the opaque value in the header. True by default. algorithm No Specified the algorithm. Defaults to MD5, the only supported option (for now). proxy_auth No Disabled by default. Enable to perform Proxy authentication, instead of normal origin server authentication. nonce timeout The current implementation of the nonce_timeout has some interesting side effects. This setting is supposed to determine the valid lifetime of a given nonce, or effectively how long a client's authentication information is accepted. As an example, if it's set to 3600, it will cause the adapter to prompt the client for new credentials every hour, on the hour. This will be resolved in a future release, once nonce tracking and stale support are implemented. Resolvers A resolver's job is to take a username and realm, and return some kind of credential value. Basic authentication expects to receive the base64-encoded version of the user's password. Digest authentication expects to receive a hash of the user's username, the realm, and their password (each separated by colons). Currently, the only supported hash algorithm is MD5. Zend\\Authentication\\Adapter\\Http relies on objects implementing Zend\\Authentication\\Adapter\\Http\\ResolverInterface . The component includes resolvers for plain text files and Apache htpasswd -generated files; you can also provide your own implementations. File Resolver The file resolver is a very simple class. It has a single property specifying a filename, which can also be passed to the constructor. Its resolve() method walks through the text file, searching for a line with a matching username and realm. The text file format is similar to Apache htpasswd files: <username>:<realm>:<credentials> Each line consists of three fields \u2014 username, realm, and credentials \u2014 each separated by a colon. The credentials field is opaque to the file resolver; it simply returns that value as-is to the caller. Therefore, this same file format serves both Basic and Digest authentication. In Basic authentication, the credentials field should be written in clear text. In Digest authentication, it should be the MD5 hash described above. There are two ways to create a file resolver: use Zend\\Authentication\\Adapter\\Http\\FileResolver; $path = 'data/passwd.txt'; $resolver = new FileResolver($path); or $path = 'data/passwd.txt'; $resolver = new FileResolver(); $resolver->setFile($path); If the given path is empty or not readable, an exception is thrown. Apache Resolver Zend\\Authentication\\Adapter\\Http\\ApacheResolver operates similarly to the FileResolver , but is capable of reading files generated by Apache's htpasswd facility, as described in the Apache documentation . In order to do so, you will need to also install zend-crypt : $ composer require zendframework/zend-crypt In all other ways, it behaves like the FileResolver , meaning you instantiate it with a path to the htpasswd -generated file, or inject the path after instantiation: use Zend\\Authentication\\Adapter\\Http\\ApacheResolver; $path = 'data/htpasswd'; // Inject at instantiation: $resolver = new ApacheResolver($path); // Or afterwards: $resolver = new ApacheResolver(); $resolver->setFile($path); Basic Usage First, set up an array with the required configuration values: $config = [ 'accept_schemes' => 'basic digest', 'realm' => 'My Web Site', 'digest_domains' => '/members_only /my_account', 'nonce_timeout' => 3600, ]; This array will cause the adapter to accept either Basic or Digest authentication, and will require authenticated access to all the areas of the site under /members_only and /my_account . The realm value is usually displayed by the browser in the password dialog box. The nonce_timeout behaves as described above. Next, create the Zend\\Authentication\\Adapter\\Http object: use Zend\\Authentication\\Adapter\\Http; $adapter = new Http($config); Since we're supporting both Basic and Digest authentication, we need two different resolver objects. use Zend\\Authentication\\Adapter\\Http\\FileResolver; $basicResolver = new FileResolver('data/basic-passwd.txt'); $digestResolver = new FileResolver('data/digest-passwd.txt'); $adapter->setBasicResolver($basicResolver); $adapter->setDigestResolver($digestResolver); Finally, we perform authentication. The adapter requires zend-http request and response instances in order to lookup credentials and provide challenge responses: use Zend\\Http\\Request; use Zend\\Http\\Response; // $request is an instance of Request // $response is an instance of Response $adapter->setRequest($request); $adapter->setResponse($response); $result = $adapter->authenticate(); if (! $result->isValid()) { // Bad username/password, or canceled password prompt }","title":"HTTP"},{"location":"adapter/http/#http-authentication-adapter","text":"Zend\\Authentication\\Adapter\\Http provides a mostly-compliant implementation of RFC-2617 , Basic and Digest HTTP Authentication. Digest authentication is a method of HTTP authentication that improves upon Basic authentication by providing a way to authenticate without having to transmit the password in clear text across the network.","title":"HTTP Authentication Adapter"},{"location":"adapter/http/#major-features","text":"Supports both Basic and Digest authentication. Issues challenges in all supported schemes, so client can respond with any scheme it supports. Supports proxy authentication. Includes support for authenticating against text files and provides an interface for authenticating against other sources, such as databases. There are a few notable features of RFC-2617 that are not implemented yet: Nonce tracking, which would allow for \"stale\" support, and increased replay attack protection. Authentication with integrity checking, or \"auth-int\". Authentication-Info HTTP header.","title":"Major Features"},{"location":"adapter/http/#requirements","text":"The HTTP authentication adapter requires zend-http in order to do its work: $ composer require zendframework/zend-http","title":"Requirements"},{"location":"adapter/http/#design-overview","text":"This adapter consists of two sub-components, the HTTP authentication class itself, and its \"Resolvers.\" The HTTP authentication class encapsulates the logic for carrying out both Basic and Digest authentication. It consumes Resolvers to look up a client's identity in some data store (text file by default), and retrieve the credentials from the data store. The \"resolved\" credentials are then compared to the values submitted by the client to determine whether authentication is successful.","title":"Design Overview"},{"location":"adapter/http/#configuration-options","text":"Zend\\Authentication\\Adapter\\Http requires a configuration array passed to its constructor. There are several configuration options available, and some are required: Option Name Required Description accept_schemes Yes Determines which authentication schemes the adapter will accept from the client. Must be a space-separated list containing basic and/or digest . realm Yes Sets the authentication realm; usernames should be unique within a given realm. digest_domains Yes, when accept_schemes contains digest Space-separated list of URIs for which the same authentication information is valid. The URIs need not all point to the same server. nonce_timeout Yes, when accept_schemes contains digest Sets the number of seconds for which the nonce is valid. See notes below. use_opaque No Specifies whether to send the opaque value in the header. True by default. algorithm No Specified the algorithm. Defaults to MD5, the only supported option (for now). proxy_auth No Disabled by default. Enable to perform Proxy authentication, instead of normal origin server authentication.","title":"Configuration Options"},{"location":"adapter/http/#nonce-timeout","text":"The current implementation of the nonce_timeout has some interesting side effects. This setting is supposed to determine the valid lifetime of a given nonce, or effectively how long a client's authentication information is accepted. As an example, if it's set to 3600, it will cause the adapter to prompt the client for new credentials every hour, on the hour. This will be resolved in a future release, once nonce tracking and stale support are implemented.","title":"nonce timeout"},{"location":"adapter/http/#resolvers","text":"A resolver's job is to take a username and realm, and return some kind of credential value. Basic authentication expects to receive the base64-encoded version of the user's password. Digest authentication expects to receive a hash of the user's username, the realm, and their password (each separated by colons). Currently, the only supported hash algorithm is MD5. Zend\\Authentication\\Adapter\\Http relies on objects implementing Zend\\Authentication\\Adapter\\Http\\ResolverInterface . The component includes resolvers for plain text files and Apache htpasswd -generated files; you can also provide your own implementations.","title":"Resolvers"},{"location":"adapter/http/#file-resolver","text":"The file resolver is a very simple class. It has a single property specifying a filename, which can also be passed to the constructor. Its resolve() method walks through the text file, searching for a line with a matching username and realm. The text file format is similar to Apache htpasswd files: <username>:<realm>:<credentials> Each line consists of three fields \u2014 username, realm, and credentials \u2014 each separated by a colon. The credentials field is opaque to the file resolver; it simply returns that value as-is to the caller. Therefore, this same file format serves both Basic and Digest authentication. In Basic authentication, the credentials field should be written in clear text. In Digest authentication, it should be the MD5 hash described above. There are two ways to create a file resolver: use Zend\\Authentication\\Adapter\\Http\\FileResolver; $path = 'data/passwd.txt'; $resolver = new FileResolver($path); or $path = 'data/passwd.txt'; $resolver = new FileResolver(); $resolver->setFile($path); If the given path is empty or not readable, an exception is thrown.","title":"File Resolver"},{"location":"adapter/http/#apache-resolver","text":"Zend\\Authentication\\Adapter\\Http\\ApacheResolver operates similarly to the FileResolver , but is capable of reading files generated by Apache's htpasswd facility, as described in the Apache documentation . In order to do so, you will need to also install zend-crypt : $ composer require zendframework/zend-crypt In all other ways, it behaves like the FileResolver , meaning you instantiate it with a path to the htpasswd -generated file, or inject the path after instantiation: use Zend\\Authentication\\Adapter\\Http\\ApacheResolver; $path = 'data/htpasswd'; // Inject at instantiation: $resolver = new ApacheResolver($path); // Or afterwards: $resolver = new ApacheResolver(); $resolver->setFile($path);","title":"Apache Resolver"},{"location":"adapter/http/#basic-usage","text":"First, set up an array with the required configuration values: $config = [ 'accept_schemes' => 'basic digest', 'realm' => 'My Web Site', 'digest_domains' => '/members_only /my_account', 'nonce_timeout' => 3600, ]; This array will cause the adapter to accept either Basic or Digest authentication, and will require authenticated access to all the areas of the site under /members_only and /my_account . The realm value is usually displayed by the browser in the password dialog box. The nonce_timeout behaves as described above. Next, create the Zend\\Authentication\\Adapter\\Http object: use Zend\\Authentication\\Adapter\\Http; $adapter = new Http($config); Since we're supporting both Basic and Digest authentication, we need two different resolver objects. use Zend\\Authentication\\Adapter\\Http\\FileResolver; $basicResolver = new FileResolver('data/basic-passwd.txt'); $digestResolver = new FileResolver('data/digest-passwd.txt'); $adapter->setBasicResolver($basicResolver); $adapter->setDigestResolver($digestResolver); Finally, we perform authentication. The adapter requires zend-http request and response instances in order to lookup credentials and provide challenge responses: use Zend\\Http\\Request; use Zend\\Http\\Response; // $request is an instance of Request // $response is an instance of Response $adapter->setRequest($request); $adapter->setResponse($response); $result = $adapter->authenticate(); if (! $result->isValid()) { // Bad username/password, or canceled password prompt }","title":"Basic Usage"},{"location":"adapter/intro/","text":"Adapters Introduction zend-authentication adapters are used to authenticate against a particular type of authentication service, such as LDAP, RDBMS, or file-based storage. Different adapters are likely to have vastly different options and behaviors, but some basic things are common among authentication adapters. For example, accepting authentication credentials (including a purported identity), performing queries against the authentication service, and returning results are common to zend-authentication adapters. AdapterInterface Each adapter implements Zend\\Authentication\\Adapter\\AdapterInterface . This interface defines one method, authenticate() , which provides the implementation for performing an authentication query. Each adapter class must be prepared prior to calling authenticate() ; such adapter preparation might include setting up credentials from user input (e.g., username and password), or defining values for adapter-specific configuration options, such as database connection settings for a database table adapter. The following is an example authentication adapter that requires a username and password to be set for authentication. Other details, such as how the authentication service is queried, have been omitted for brevity: <?php namespace My\\Auth; use Zend\\Authentication\\Adapter\\AdapterInterface; class Adapter implements AdapterInterface { /** * Sets username and password for authentication * * @return void */ public function __construct($username, $password) { // ... } /** * Performs an authentication attempt * * @return \\Zend\\Authentication\\Result * @throws \\Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface * If authentication cannot be performed */ public function authenticate() { // ... } } As indicated in its docblock, authenticate() must return an instance of Zend\\Authentication\\Result (or of a class derived from Zend\\Authentication\\Result ). If performing an authentication query is impossible, authenticate() should throw an exception that derives from Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface . Results Authentication adapters return an instance of Zend\\Authentication\\Result from authenticate() in order to represent the results of an authentication attempt. Adapters populate the Zend\\Authentication\\Result object upon construction: namespace Zend\\Authentication; class Result { /** * @param int $code * @param mixed $identity * @param array $messages */ public function __construct($code, $identity, array $messages = []); } where: $code is an integer indicating the result status. Typically you will use one of the constants defined in the Result class to provide this; a table follows detailing those. $identity is the value representing the authenticated identity. This may be any PHP type; typically you will see a string username or token, or an object type specific to the application or login module you utilize. When the result represents a failure to authenticate, this will often be null; some systems will provide a default identity in such cases. $messages is an array of authentication failure messages. The following result codes are available: namespace Zend\\Authentication; class Result { const SUCCESS = 1; const FAILURE = 0; const FAILURE_IDENTITY_NOT_FOUND = -1; const FAILURE_IDENTITY_AMBIGUOUS = -2; const FAILURE_CREDENTIAL_INVALID = -3; const FAILURE_UNCATEGORIZED = -4; } Note that success is a truthy value, while failure of any sort is a falsy value. Results provide the following four user-facing operations: isValid() returns TRUE if and only if the result represents a successful authentication attempt. getCode() returns the Zend\\Authentication\\Result constant identifier associated with the specific result. This may be used in situations where the developer wishes to distinguish among several authentication result types. This allows developers to maintain detailed authentication result statistics, for example. Another use of this feature is to provide specific, customized messages to users for usability reasons, though developers are encouraged to consider the risks of providing such detailed reasons to users, instead of a general authentication failure message. For more information, see the notes below. getIdentity() returns the identity of the authentication attempt. getMessages() returns an array of messages regarding a failed authentication attempt. A developer may wish to branch based on the type of authentication result in order to perform more specific operations. Some operations developers might find useful are locking accounts after too many unsuccessful password attempts, flagging an IP address after too many nonexistent identities are attempted, and providing specific, customized authentication result messages to the user. The following example illustrates how a developer may branch on the result code: $result = $authenticationService->authenticate($adapter); switch ($result->getCode()) { case Result::FAILURE_IDENTITY_NOT_FOUND: /** do stuff for nonexistent identity **/ break; case Result::FAILURE_CREDENTIAL_INVALID: /** do stuff for invalid credential **/ break; case Result::SUCCESS: /** do stuff for successful authentication **/ break; default: /** do stuff for other failure **/ break; }","title":"Intro"},{"location":"adapter/intro/#adapters-introduction","text":"zend-authentication adapters are used to authenticate against a particular type of authentication service, such as LDAP, RDBMS, or file-based storage. Different adapters are likely to have vastly different options and behaviors, but some basic things are common among authentication adapters. For example, accepting authentication credentials (including a purported identity), performing queries against the authentication service, and returning results are common to zend-authentication adapters.","title":"Adapters Introduction"},{"location":"adapter/intro/#adapterinterface","text":"Each adapter implements Zend\\Authentication\\Adapter\\AdapterInterface . This interface defines one method, authenticate() , which provides the implementation for performing an authentication query. Each adapter class must be prepared prior to calling authenticate() ; such adapter preparation might include setting up credentials from user input (e.g., username and password), or defining values for adapter-specific configuration options, such as database connection settings for a database table adapter. The following is an example authentication adapter that requires a username and password to be set for authentication. Other details, such as how the authentication service is queried, have been omitted for brevity: <?php namespace My\\Auth; use Zend\\Authentication\\Adapter\\AdapterInterface; class Adapter implements AdapterInterface { /** * Sets username and password for authentication * * @return void */ public function __construct($username, $password) { // ... } /** * Performs an authentication attempt * * @return \\Zend\\Authentication\\Result * @throws \\Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface * If authentication cannot be performed */ public function authenticate() { // ... } } As indicated in its docblock, authenticate() must return an instance of Zend\\Authentication\\Result (or of a class derived from Zend\\Authentication\\Result ). If performing an authentication query is impossible, authenticate() should throw an exception that derives from Zend\\Authentication\\Adapter\\Exception\\ExceptionInterface .","title":"AdapterInterface"},{"location":"adapter/intro/#results","text":"Authentication adapters return an instance of Zend\\Authentication\\Result from authenticate() in order to represent the results of an authentication attempt. Adapters populate the Zend\\Authentication\\Result object upon construction: namespace Zend\\Authentication; class Result { /** * @param int $code * @param mixed $identity * @param array $messages */ public function __construct($code, $identity, array $messages = []); } where: $code is an integer indicating the result status. Typically you will use one of the constants defined in the Result class to provide this; a table follows detailing those. $identity is the value representing the authenticated identity. This may be any PHP type; typically you will see a string username or token, or an object type specific to the application or login module you utilize. When the result represents a failure to authenticate, this will often be null; some systems will provide a default identity in such cases. $messages is an array of authentication failure messages. The following result codes are available: namespace Zend\\Authentication; class Result { const SUCCESS = 1; const FAILURE = 0; const FAILURE_IDENTITY_NOT_FOUND = -1; const FAILURE_IDENTITY_AMBIGUOUS = -2; const FAILURE_CREDENTIAL_INVALID = -3; const FAILURE_UNCATEGORIZED = -4; } Note that success is a truthy value, while failure of any sort is a falsy value. Results provide the following four user-facing operations: isValid() returns TRUE if and only if the result represents a successful authentication attempt. getCode() returns the Zend\\Authentication\\Result constant identifier associated with the specific result. This may be used in situations where the developer wishes to distinguish among several authentication result types. This allows developers to maintain detailed authentication result statistics, for example. Another use of this feature is to provide specific, customized messages to users for usability reasons, though developers are encouraged to consider the risks of providing such detailed reasons to users, instead of a general authentication failure message. For more information, see the notes below. getIdentity() returns the identity of the authentication attempt. getMessages() returns an array of messages regarding a failed authentication attempt. A developer may wish to branch based on the type of authentication result in order to perform more specific operations. Some operations developers might find useful are locking accounts after too many unsuccessful password attempts, flagging an IP address after too many nonexistent identities are attempted, and providing specific, customized authentication result messages to the user. The following example illustrates how a developer may branch on the result code: $result = $authenticationService->authenticate($adapter); switch ($result->getCode()) { case Result::FAILURE_IDENTITY_NOT_FOUND: /** do stuff for nonexistent identity **/ break; case Result::FAILURE_CREDENTIAL_INVALID: /** do stuff for invalid credential **/ break; case Result::SUCCESS: /** do stuff for successful authentication **/ break; default: /** do stuff for other failure **/ break; }","title":"Results"},{"location":"adapter/ldap/","text":"LDAP Authentication Zend\\Authentication\\Adapter\\Ldap supports web application authentication with LDAP services. Its features include username and domain name canonicalization, multi-domain authentication, and failover capabilities. It has been tested to work with Microsoft Active Directory and OpenLDAP , but it should also work with other LDAP service providers. This documentation includes a guide on using Zend\\Authentication\\Adapter\\Ldap , an exploration of its API, an outline of the various available options, diagnostic information for troubleshooting authentication problems, and example options for both Active Directory and OpenLDAP servers. Usage The following example demonstrates creating and configuring the Ldap authentication adapter, and also illustrates how to work with the authentication messages returned in the authentication result. use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Adapter\\Ldap as LdapAdapter; // Retrieve the username and pasword from the request somehow. $username = /* ... */; $password = /* ... */; $auth = new AuthenticationService(); $config = [ 'server1' => [ 'host' => 's0.foo.net', 'accountDomainName' => 'foo.net', 'accountDomainNameShort' => 'FOO', 'accountCanonicalForm' => 3, 'username' => 'CN=user1,DC=foo,DC=net', 'password' => 'pass1', 'baseDn' => 'OU=Sales,DC=foo,DC=net', 'bindRequiresDn' => true, ], 'server2' => [ 'host' => 'dc1.w.net', 'useStartTls' => true, 'accountDomainName' => 'w.net', 'accountDomainNameShort' => 'W', 'accountCanonicalForm' => 3, 'baseDn' => 'CN=Users,DC=w,DC=net', ], ]; $adapter = new LdapAdapter($config, $username, $password); $result = $auth->authenticate($adapter); // Messages from position 2 and up are informational messages from the LDAP // server: foreach ($result->getMessages() as $i => $message) { if ($i < 2) { continue; } // Potentially log the $message } As noted in the above example, the returned authentication result contains messages even on success. LDAP has some notoriety for difficulty in debugging, and the Ldap adapter attempts to assist you with this by providing informational messages for every authentication attempt. A later section in this document provides more detail on the messages returned. You will note that the configuration contains information for multiple servers. When multiple server configuration is provided, the adapter will loop through each until one provides successful authentication. The above configuration will instruct the adapter to attempt authenticattion against the OpenLDAP server s0.foo.net first, falling back to the Active Directory server dc1.w.net on failure. With servers in different domains, this configuration illustrates multi-domain authentication. You can also have multiple servers in the same domain to provide redundancy. Note that in this case, even though OpenLDAP has no need for the short NetBIOS style domain name used by Windows, we provide it here for name canonicalization purposes (described in the Username Canonicalization section below). A later section on server options details all available options) The API The Zend\\Authentication\\Adapter\\Ldap constructor accepts three parameters. The $options parameter is required and must be an array containing one or more sets of options. Note that it is an array of arrays , with each sub-array providing zend-ldap options. Even if you will be using only one LDAP server, the options must still be within a sub-array. Referring back to the example in the previous section, the information provided in each set of options is different mainly because Active Directory does not require a username be in DN form when binding (see the bindRequiresDn option in the Server Options section below), which means we can omit a number of options associated with retrieving the DN for a username being authenticated. What is a Distinguished Name? A DN or \"distinguished name\" is a string that represents the path to an object within the LDAP directory. Each comma-separated component is an attribute and value representing a node. The components are evaluated in reverse. For example, the user account CN=Bob Carter,CN=Users,DC=w,DC=net is located directly within the CN=Users,DC=w,DC=net container . This structure is best explored with an LDAP browser like the ADSI Edit MMC snap-in for Active Directory or phpLDAPadmin. The names of servers (e.g. 'server1' and 'server2' shown above) are largely arbitrary and only used for informational purposes by the adapter. We recommend using string identifiers that omit any HTML/XML entity references to ensure they do not break any logging displays. With multiple sets of server options, the adapter can authenticate users in multiple domains and provide failover so that if one server is not available, another will be queried. The Gory Details: What Happens in the Authenticate Method? When the authenticate() method is called, the adapter iterates over each set of server options, passes them to the internal Zend\\Ldap\\Ldap instance, and calls the Zend\\Ldap\\Ldap::bind() method with the username and password being authenticated. Zend\\Ldap\\Ldap checks to see if the username is qualified with a domain (e.g., has a domain component like alice@foo.net or FOO\\alice ). If a domain is present, but does not match either of the server's domain names (e.g., foo.net or FOO ), a special exception is thrown and caught by Zend\\Authentication\\Adapter\\Ldap that causes that server to be ignored, and progression to the next server configured. If a domain matches, or if the user did not supply a qualified username, Zend\\Ldap\\Ldap proceeds to try to bind with the supplied credentials. if the bind is unsuccessful, Zend\\Ldap\\Ldap throws a Zend\\Ldap\\Exception\\LdapException which is caught by Zend\\Authentication\\Adapter\\Ldap and, again, the adapter progresses to the next configured server. If the bind is successful, server iteration stops, and the adapter's authenticate() method returns a successful result. If all configured servers fail to authenticate, authenticate() returns a failure result with error messages from the last server consulted. The username and password parameters of the Zend\\Authentication\\Adapter\\Ldap constructor represent the credentials being authenticated (i.e., the credentials supplied by the user through your HTML login form). Alternatively, they may also be set with the setUsername() and setPassword() methods. Server Options Each set of server options in the context of Zend\\Authentication\\Adapter\\Ldap consists of the following options, which are passed, largely unmodified, to Zend\\Ldap\\Ldap::setOptions() : Name Description host The hostname of LDAP server that these options represent. This option is required. port The port on which the LDAP server is listening. If useSsl is TRUE , the default port value is 636. If useSsl is FALSE , the default port value is 389. useStartTls Whether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of TRUE is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is FALSE , as servers frequently require that a certificate be installed separately after installation. The useSsl and useStartTls options are mutually exclusive. The useStartTls option should be favored over useSsl , but not all servers support this newer mechanism. useSsl Whether or not the LDAP client should use SSL encrypted transport. The useSsl and useStartTls options are mutually exclusive, but useStartTls should be favored if the server and LDAP client library support it. This value also changes the default port value (see port description above). username The DN of the account used to perform account DN lookups. LDAP servers that require the username to be in DN form when performing the \u201cbind\u201d require this option. Meaning, if bindRequiresDn is TRUE , this option is required. This account does not need to be a privileged account; an account with read-only access to objects under the baseDn is all that is necessary (and preferred based on the Principle of Least Privilege). password The password of the account used to perform account DN lookups. If this option is not supplied, the LDAP client will attempt an \u201canonymous bind\u201d when performing account DN lookups. bindRequiresDn Some LDAP servers require that the username used to bind be in DN form like CN=Alice Baker,OU=Sales,DC=foo,DC=net (basically all servers except Active Directory). If this option is TRUE , this instructs Zend\\Ldap\\Ldap to automatically retrieve the DN corresponding to the username being authenticated, if it is not already in DN form, and then re-bind with the proper DN. The default value is FALSE . Currently only Microsoft Active Directory Server (ADS) is known not to require usernames to be in DN form when binding, and therefore this option may be FALSE with AD (and it should be, as retrieving the DN requires an extra round trip to the server). Otherwise, this option must be set to TRUE (e.g. for OpenLDAP). This option also controls the default accountFilterFormat used when searching for accounts. See the accountFilterFormat option. baseDn The DN under which all accounts being authenticated are located. This option is required. if you are uncertain about the correct baseDn value, it should be sufficient to derive it from the user\u2019s DNS domain using DC= components. For example, if the user\u2019s principal name is alice@foo.net , a baseDn of DC=foo,DC=net should work. A more precise location (e.g., OU=Sales,DC=foo,DC=net ) will be more efficient, however. accountCanonicalForm A value of 2, 3, or 4 indicating the form to which account names should be canonicalized after successful authentication. Values are as follows: 2 for traditional username style names (e.g., alice ), 3 for backslash-style names (e.g., FOO\\alice ) or 4 for principal style usernames (e.g., alice@foo.net ). The default value is 4 (e.g., alice@foo.net ). For example, with a value of 3, the identity returned by Zend\\Authentication\\Result::getIdentity() (and Zend\\Authentication\\AuthenticationService::getIdentity() , if Zend\\Authentication\\AuthenticationService was used) will always be FOO\\alice , regardless of what form Alice supplied, whether it be alice , alice@foo.net , FOO\\alice , FoO\\aLicE , foo.net\\alice , etc. See the Account Name Canonicalization section in the zend-ldap documentation for details. Note that when using multiple sets of server options it is recommended, but not required, that the same accountCanonicalForm be used with all server options so that the resulting usernames are always canonicalized to the same form (e.g., if you canonicalize to EXAMPLE\\username with an AD server but to username@example.com with an OpenLDAP server, that may be awkward for the application\u2019s high-level logic). accountDomainName The FQDN domain name for which the target LDAP server is an authority (e.g., example.com ). This option is used to canonicalize names so that the username supplied by the user can be converted as necessary for binding. It is also used to determine if the server is an authority for the supplied username (e.g., if accountDomainName is foo.net and the user supplies bob@bar.net , the server will not be queried, and a failure will result). This option is not required, but if it is not supplied, usernames in principal name form (e.g., alice@foo.net ) are not supported. It is strongly recommended that you supply this option, as there are many use-cases that require generating the principal name form. accountDomainNameShort The \u2018short\u2019 domain for which the target LDAP server is an authority (e.g., FOO ). Note that there is a 1:1 mapping between the accountDomainName and accountDomainNameShort . This option should be used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers (e.g., for consistency when multiple sets of server options with the backslash style accountCanonicalForm ). This option is not required but if it is not supplied, usernames in backslash form (e.g., FOO\\alice ) are not supported. accountFilterFormat The LDAP search filter used to search for accounts. This string is a printf() -style expression that must contain one %s to accommodate the username. The default value is (&(objectClass=user)(sAMAccountName=%s)) , unless bindRequiresDn is set to TRUE , in which case the default is (&(objectClass=posixAccount)(uid=%s)) . For example, if for some reason you wanted to use bindRequiresDn = true with AD you would need to set accountFilterFormat = '(&(objectClass=user)(sAMAccountName=%s))' . optReferrals If set to TRUE , this option indicates to the LDAP client that referrals should be followed. The default value is FALSE . TLS and SSL If you enable useStartTls = TRUE or useSsl = TRUE you may find that the LDAP client generates an error claiming that it cannot validate the server's certificate. Assuming the PHP LDAP extension is ultimately linked to the OpenLDAP client libraries, to resolve this issue you can set TLS_REQCERT never in the OpenLDAP client ldap.conf (and restart the web server) to indicate to the OpenLDAP client library that you trust the server. Alternately, if you are concerned that the server could be spoofed, you can export the LDAP server's root certificate and put it on the web server so that the OpenLDAP client can validate the server's identity. Collecting Debugging Messages Zend\\Authentication\\Adapter\\Ldap collects debugging information within its authenticate() method. This information is stored in the Zend\\Authentication\\Result object as messages. The array returned by Zend\\Authentication\\Result::getMessages() is described as follows: Messages Array Index Description Index 0 A generic, user-friendly message that is suitable for displaying to users (e.g., \"Invalid credentials\"). If the authentication is successful, this string is empty. Index 1 A more detailed error message that is not suitable to be displayed to users but should be logged for the benefit of server operators. If the authentication is successful, this string is empty. Indexes 2 and higher All log messages in order starting at index 2. In practice, index 0 should be displayed to the user (e.g., using the FlashMessenger helper ), index 1 should be logged and, if debugging information is being collected, indexes 2 and higher could be logged as well (although the final message always includes the string from index 1). Common Options for Specific Servers Options for Active Directory For AD*, the following options are noteworthy: Name Additional Notes host As with all servers, this option is required. useStartTls For the sake of security, this should be TRUE if the server has the necessary certificate installed. useSsl Possibly used as an alternative to useStartTls (see above). baseDn As with all servers, this option is required. By default, AD places all user accounts under the Users container (e.g., CN=Users,DC=foo,DC=net ), but the default is not common in larger organizations. Ask your AD administrator what the best DN for accounts for your application would be. accountCanonicalForm You almost certainly want this to be 3 for backslash style names (e.g., FOO\\alice ), which are most familiar to Windows users. You should not use the unqualified form 2 (e.g., alice ), as this may grant access to your application to users with the same username in other trusted domains (e.g., BAR\\alice and FOO\\alice will be treated as the same user). (See also note below.) accountDomainName This is required with AD unless accountCanonicalForm 2 is used, which, again, is discouraged. accountDomainNameShort The NetBIOS name of the domain that users are in and for which the AD server is an authority. This is required if the backslash style accountCanonicalForm is used. Use qualified account names Technically there should be no danger of accidental cross-domain authentication with the current Zend\\Authentication\\Adapter\\Ldap implementation, since server domains are explicitly checked, but this may not be true of a future implementation that discovers the domain at runtime, or if an alternative adapter is used (e.g., Kerberos). In general, account name ambiguity is known to be the source of security issues, so always try to use qualified account names. Options for OpenLDAP For OpenLDAP or a generic LDAP server using a typical posixAccount style schema, the following options are noteworthy: Name Additional Notes host As with all servers, this option is required. useStartTls For the sake of security, this should be TRUE if the server has the necessary certificate installed. useSsl Possibly used as an alternative to useStartTls (see above). username Required and must be a DN, as OpenLDAP requires that usernames be in DN form when performing a bind. Try to use an unprivileged account. password The password corresponding to the username above, but this may be omitted if the LDAP server permits an anonymous binding to query user accounts. bindRequiresDn Required and must be TRUE, as OpenLDAP requires that usernames be in DN form when performing a bind. baseDn As with all servers, this option is required and indicates the DN under which all accounts being authenticated are located. accountCanonicalForm Optional, but the default value is 4 (principal style names like alice@foo.net ), which may not be ideal if your users are used to backslash style names (e.g., FOO\\alice ). For backslash style names, use value 3. accountDomainName Required unless you're using accountCanonicalForm 2, which is not recommended. accountDomainNameShort If AD is not also being used, this value is not required. Otherwise, if accountCanonicalForm 3 is used, this option is required and should be a short name that corresponds adequately to the accountDomainName (e.g., if your accountDomainName is foo.net , a good accountDomainNameShort value might be FOO ).","title":"LDAP"},{"location":"adapter/ldap/#ldap-authentication","text":"Zend\\Authentication\\Adapter\\Ldap supports web application authentication with LDAP services. Its features include username and domain name canonicalization, multi-domain authentication, and failover capabilities. It has been tested to work with Microsoft Active Directory and OpenLDAP , but it should also work with other LDAP service providers. This documentation includes a guide on using Zend\\Authentication\\Adapter\\Ldap , an exploration of its API, an outline of the various available options, diagnostic information for troubleshooting authentication problems, and example options for both Active Directory and OpenLDAP servers.","title":"LDAP Authentication"},{"location":"adapter/ldap/#usage","text":"The following example demonstrates creating and configuring the Ldap authentication adapter, and also illustrates how to work with the authentication messages returned in the authentication result. use Zend\\Authentication\\AuthenticationService; use Zend\\Authentication\\Adapter\\Ldap as LdapAdapter; // Retrieve the username and pasword from the request somehow. $username = /* ... */; $password = /* ... */; $auth = new AuthenticationService(); $config = [ 'server1' => [ 'host' => 's0.foo.net', 'accountDomainName' => 'foo.net', 'accountDomainNameShort' => 'FOO', 'accountCanonicalForm' => 3, 'username' => 'CN=user1,DC=foo,DC=net', 'password' => 'pass1', 'baseDn' => 'OU=Sales,DC=foo,DC=net', 'bindRequiresDn' => true, ], 'server2' => [ 'host' => 'dc1.w.net', 'useStartTls' => true, 'accountDomainName' => 'w.net', 'accountDomainNameShort' => 'W', 'accountCanonicalForm' => 3, 'baseDn' => 'CN=Users,DC=w,DC=net', ], ]; $adapter = new LdapAdapter($config, $username, $password); $result = $auth->authenticate($adapter); // Messages from position 2 and up are informational messages from the LDAP // server: foreach ($result->getMessages() as $i => $message) { if ($i < 2) { continue; } // Potentially log the $message } As noted in the above example, the returned authentication result contains messages even on success. LDAP has some notoriety for difficulty in debugging, and the Ldap adapter attempts to assist you with this by providing informational messages for every authentication attempt. A later section in this document provides more detail on the messages returned. You will note that the configuration contains information for multiple servers. When multiple server configuration is provided, the adapter will loop through each until one provides successful authentication. The above configuration will instruct the adapter to attempt authenticattion against the OpenLDAP server s0.foo.net first, falling back to the Active Directory server dc1.w.net on failure. With servers in different domains, this configuration illustrates multi-domain authentication. You can also have multiple servers in the same domain to provide redundancy. Note that in this case, even though OpenLDAP has no need for the short NetBIOS style domain name used by Windows, we provide it here for name canonicalization purposes (described in the Username Canonicalization section below). A later section on server options details all available options)","title":"Usage"},{"location":"adapter/ldap/#the-api","text":"The Zend\\Authentication\\Adapter\\Ldap constructor accepts three parameters. The $options parameter is required and must be an array containing one or more sets of options. Note that it is an array of arrays , with each sub-array providing zend-ldap options. Even if you will be using only one LDAP server, the options must still be within a sub-array. Referring back to the example in the previous section, the information provided in each set of options is different mainly because Active Directory does not require a username be in DN form when binding (see the bindRequiresDn option in the Server Options section below), which means we can omit a number of options associated with retrieving the DN for a username being authenticated.","title":"The API"},{"location":"adapter/ldap/#what-is-a-distinguished-name","text":"A DN or \"distinguished name\" is a string that represents the path to an object within the LDAP directory. Each comma-separated component is an attribute and value representing a node. The components are evaluated in reverse. For example, the user account CN=Bob Carter,CN=Users,DC=w,DC=net is located directly within the CN=Users,DC=w,DC=net container . This structure is best explored with an LDAP browser like the ADSI Edit MMC snap-in for Active Directory or phpLDAPadmin. The names of servers (e.g. 'server1' and 'server2' shown above) are largely arbitrary and only used for informational purposes by the adapter. We recommend using string identifiers that omit any HTML/XML entity references to ensure they do not break any logging displays. With multiple sets of server options, the adapter can authenticate users in multiple domains and provide failover so that if one server is not available, another will be queried.","title":"What is a Distinguished Name?"},{"location":"adapter/ldap/#the-gory-details-what-happens-in-the-authenticate-method","text":"When the authenticate() method is called, the adapter iterates over each set of server options, passes them to the internal Zend\\Ldap\\Ldap instance, and calls the Zend\\Ldap\\Ldap::bind() method with the username and password being authenticated. Zend\\Ldap\\Ldap checks to see if the username is qualified with a domain (e.g., has a domain component like alice@foo.net or FOO\\alice ). If a domain is present, but does not match either of the server's domain names (e.g., foo.net or FOO ), a special exception is thrown and caught by Zend\\Authentication\\Adapter\\Ldap that causes that server to be ignored, and progression to the next server configured. If a domain matches, or if the user did not supply a qualified username, Zend\\Ldap\\Ldap proceeds to try to bind with the supplied credentials. if the bind is unsuccessful, Zend\\Ldap\\Ldap throws a Zend\\Ldap\\Exception\\LdapException which is caught by Zend\\Authentication\\Adapter\\Ldap and, again, the adapter progresses to the next configured server. If the bind is successful, server iteration stops, and the adapter's authenticate() method returns a successful result. If all configured servers fail to authenticate, authenticate() returns a failure result with error messages from the last server consulted. The username and password parameters of the Zend\\Authentication\\Adapter\\Ldap constructor represent the credentials being authenticated (i.e., the credentials supplied by the user through your HTML login form). Alternatively, they may also be set with the setUsername() and setPassword() methods.","title":"The Gory Details: What Happens in the Authenticate Method?"},{"location":"adapter/ldap/#server-options","text":"Each set of server options in the context of Zend\\Authentication\\Adapter\\Ldap consists of the following options, which are passed, largely unmodified, to Zend\\Ldap\\Ldap::setOptions() : Name Description host The hostname of LDAP server that these options represent. This option is required. port The port on which the LDAP server is listening. If useSsl is TRUE , the default port value is 636. If useSsl is FALSE , the default port value is 389. useStartTls Whether or not the LDAP client should use TLS (aka SSLv2) encrypted transport. A value of TRUE is strongly favored in production environments to prevent passwords from be transmitted in clear text. The default value is FALSE , as servers frequently require that a certificate be installed separately after installation. The useSsl and useStartTls options are mutually exclusive. The useStartTls option should be favored over useSsl , but not all servers support this newer mechanism. useSsl Whether or not the LDAP client should use SSL encrypted transport. The useSsl and useStartTls options are mutually exclusive, but useStartTls should be favored if the server and LDAP client library support it. This value also changes the default port value (see port description above). username The DN of the account used to perform account DN lookups. LDAP servers that require the username to be in DN form when performing the \u201cbind\u201d require this option. Meaning, if bindRequiresDn is TRUE , this option is required. This account does not need to be a privileged account; an account with read-only access to objects under the baseDn is all that is necessary (and preferred based on the Principle of Least Privilege). password The password of the account used to perform account DN lookups. If this option is not supplied, the LDAP client will attempt an \u201canonymous bind\u201d when performing account DN lookups. bindRequiresDn Some LDAP servers require that the username used to bind be in DN form like CN=Alice Baker,OU=Sales,DC=foo,DC=net (basically all servers except Active Directory). If this option is TRUE , this instructs Zend\\Ldap\\Ldap to automatically retrieve the DN corresponding to the username being authenticated, if it is not already in DN form, and then re-bind with the proper DN. The default value is FALSE . Currently only Microsoft Active Directory Server (ADS) is known not to require usernames to be in DN form when binding, and therefore this option may be FALSE with AD (and it should be, as retrieving the DN requires an extra round trip to the server). Otherwise, this option must be set to TRUE (e.g. for OpenLDAP). This option also controls the default accountFilterFormat used when searching for accounts. See the accountFilterFormat option. baseDn The DN under which all accounts being authenticated are located. This option is required. if you are uncertain about the correct baseDn value, it should be sufficient to derive it from the user\u2019s DNS domain using DC= components. For example, if the user\u2019s principal name is alice@foo.net , a baseDn of DC=foo,DC=net should work. A more precise location (e.g., OU=Sales,DC=foo,DC=net ) will be more efficient, however. accountCanonicalForm A value of 2, 3, or 4 indicating the form to which account names should be canonicalized after successful authentication. Values are as follows: 2 for traditional username style names (e.g., alice ), 3 for backslash-style names (e.g., FOO\\alice ) or 4 for principal style usernames (e.g., alice@foo.net ). The default value is 4 (e.g., alice@foo.net ). For example, with a value of 3, the identity returned by Zend\\Authentication\\Result::getIdentity() (and Zend\\Authentication\\AuthenticationService::getIdentity() , if Zend\\Authentication\\AuthenticationService was used) will always be FOO\\alice , regardless of what form Alice supplied, whether it be alice , alice@foo.net , FOO\\alice , FoO\\aLicE , foo.net\\alice , etc. See the Account Name Canonicalization section in the zend-ldap documentation for details. Note that when using multiple sets of server options it is recommended, but not required, that the same accountCanonicalForm be used with all server options so that the resulting usernames are always canonicalized to the same form (e.g., if you canonicalize to EXAMPLE\\username with an AD server but to username@example.com with an OpenLDAP server, that may be awkward for the application\u2019s high-level logic). accountDomainName The FQDN domain name for which the target LDAP server is an authority (e.g., example.com ). This option is used to canonicalize names so that the username supplied by the user can be converted as necessary for binding. It is also used to determine if the server is an authority for the supplied username (e.g., if accountDomainName is foo.net and the user supplies bob@bar.net , the server will not be queried, and a failure will result). This option is not required, but if it is not supplied, usernames in principal name form (e.g., alice@foo.net ) are not supported. It is strongly recommended that you supply this option, as there are many use-cases that require generating the principal name form. accountDomainNameShort The \u2018short\u2019 domain for which the target LDAP server is an authority (e.g., FOO ). Note that there is a 1:1 mapping between the accountDomainName and accountDomainNameShort . This option should be used to specify the NetBIOS domain name for Windows networks, but may also be used by non-AD servers (e.g., for consistency when multiple sets of server options with the backslash style accountCanonicalForm ). This option is not required but if it is not supplied, usernames in backslash form (e.g., FOO\\alice ) are not supported. accountFilterFormat The LDAP search filter used to search for accounts. This string is a printf() -style expression that must contain one %s to accommodate the username. The default value is (&(objectClass=user)(sAMAccountName=%s)) , unless bindRequiresDn is set to TRUE , in which case the default is (&(objectClass=posixAccount)(uid=%s)) . For example, if for some reason you wanted to use bindRequiresDn = true with AD you would need to set accountFilterFormat = '(&(objectClass=user)(sAMAccountName=%s))' . optReferrals If set to TRUE , this option indicates to the LDAP client that referrals should be followed. The default value is FALSE .","title":"Server Options"},{"location":"adapter/ldap/#tls-and-ssl","text":"If you enable useStartTls = TRUE or useSsl = TRUE you may find that the LDAP client generates an error claiming that it cannot validate the server's certificate. Assuming the PHP LDAP extension is ultimately linked to the OpenLDAP client libraries, to resolve this issue you can set TLS_REQCERT never in the OpenLDAP client ldap.conf (and restart the web server) to indicate to the OpenLDAP client library that you trust the server. Alternately, if you are concerned that the server could be spoofed, you can export the LDAP server's root certificate and put it on the web server so that the OpenLDAP client can validate the server's identity.","title":"TLS and SSL"},{"location":"adapter/ldap/#collecting-debugging-messages","text":"Zend\\Authentication\\Adapter\\Ldap collects debugging information within its authenticate() method. This information is stored in the Zend\\Authentication\\Result object as messages. The array returned by Zend\\Authentication\\Result::getMessages() is described as follows: Messages Array Index Description Index 0 A generic, user-friendly message that is suitable for displaying to users (e.g., \"Invalid credentials\"). If the authentication is successful, this string is empty. Index 1 A more detailed error message that is not suitable to be displayed to users but should be logged for the benefit of server operators. If the authentication is successful, this string is empty. Indexes 2 and higher All log messages in order starting at index 2. In practice, index 0 should be displayed to the user (e.g., using the FlashMessenger helper ), index 1 should be logged and, if debugging information is being collected, indexes 2 and higher could be logged as well (although the final message always includes the string from index 1).","title":"Collecting Debugging Messages"},{"location":"adapter/ldap/#common-options-for-specific-servers","text":"","title":"Common Options for Specific Servers"},{"location":"adapter/ldap/#options-for-active-directory","text":"For AD*, the following options are noteworthy: Name Additional Notes host As with all servers, this option is required. useStartTls For the sake of security, this should be TRUE if the server has the necessary certificate installed. useSsl Possibly used as an alternative to useStartTls (see above). baseDn As with all servers, this option is required. By default, AD places all user accounts under the Users container (e.g., CN=Users,DC=foo,DC=net ), but the default is not common in larger organizations. Ask your AD administrator what the best DN for accounts for your application would be. accountCanonicalForm You almost certainly want this to be 3 for backslash style names (e.g., FOO\\alice ), which are most familiar to Windows users. You should not use the unqualified form 2 (e.g., alice ), as this may grant access to your application to users with the same username in other trusted domains (e.g., BAR\\alice and FOO\\alice will be treated as the same user). (See also note below.) accountDomainName This is required with AD unless accountCanonicalForm 2 is used, which, again, is discouraged. accountDomainNameShort The NetBIOS name of the domain that users are in and for which the AD server is an authority. This is required if the backslash style accountCanonicalForm is used.","title":"Options for Active Directory"},{"location":"adapter/ldap/#use-qualified-account-names","text":"Technically there should be no danger of accidental cross-domain authentication with the current Zend\\Authentication\\Adapter\\Ldap implementation, since server domains are explicitly checked, but this may not be true of a future implementation that discovers the domain at runtime, or if an alternative adapter is used (e.g., Kerberos). In general, account name ambiguity is known to be the source of security issues, so always try to use qualified account names.","title":"Use qualified account names"},{"location":"adapter/ldap/#options-for-openldap","text":"For OpenLDAP or a generic LDAP server using a typical posixAccount style schema, the following options are noteworthy: Name Additional Notes host As with all servers, this option is required. useStartTls For the sake of security, this should be TRUE if the server has the necessary certificate installed. useSsl Possibly used as an alternative to useStartTls (see above). username Required and must be a DN, as OpenLDAP requires that usernames be in DN form when performing a bind. Try to use an unprivileged account. password The password corresponding to the username above, but this may be omitted if the LDAP server permits an anonymous binding to query user accounts. bindRequiresDn Required and must be TRUE, as OpenLDAP requires that usernames be in DN form when performing a bind. baseDn As with all servers, this option is required and indicates the DN under which all accounts being authenticated are located. accountCanonicalForm Optional, but the default value is 4 (principal style names like alice@foo.net ), which may not be ideal if your users are used to backslash style names (e.g., FOO\\alice ). For backslash style names, use value 3. accountDomainName Required unless you're using accountCanonicalForm 2, which is not recommended. accountDomainNameShort If AD is not also being used, this value is not required. Otherwise, if accountCanonicalForm 3 is used, this option is required and should be a short name that corresponds adequately to the accountDomainName (e.g., if your accountDomainName is foo.net , a good accountDomainNameShort value might be FOO ).","title":"Options for OpenLDAP"},{"location":"adapter/dbtable/callback-check/","text":"Callback Verification Some verification operations cannot be performed well on RDBMS servers. Other times, you may be unsure which RDBMS system you will be using long-term, and need to ensure authentication will work consistently. For these situations, you can use the Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter adapter. Similar to the CredentialTreatmentAdapter , it accepts a table name, identity column, and credential column; however, instead of a credential treatment, it accepts a credential validation callback that is executed when the database returns any matches, and which can be used to perform additional credential verifications. Configuration options The available configuration options include: tableName : This is the name of the database table that contains the authentication credentials, and against which the database authentication query is performed. identityColumn : This is the name of the database table column used to represent the identity. The identity column must contain unique values, such as a username or e-mail address. credentialColumn : This is the name of the database table column used to represent the credential. Under a simple identity and password authentication scheme, the credential value corresponds to the password. credentialValidationCallback : A PHP callable to execute when the database returns matches. The callback will receive: the value of the credentialColumn returned from the database the credential that was used by the adapter during authentication Basic Usage Many databases do not provide functions that implement a cryptographically secure hashing mechanism. Additionally, you may want to ensure that should you switch database systems, hashing is consistent. This is a perfect use case for the CallbackCheckAdapter adapter; you can implement the password hashing and verification within PHP instead. The following code creates an adapter for an in-memory database, creates a simple table schema, and inserts a row against which we can perform an authentication query later. This example requires the PDO SQLite extension to be available: use Zend\\Db\\Adapter\\Adapter as DbAdapter; // Create a SQLite database connection $dbAdapter = new DbAdapter([ 'driver' => 'Pdo_Sqlite', 'database' => 'data/sqlite.db', ]); // Build a simple table creation query $sqlCreate = 'CREATE TABLE [users] (' . '[id] INTEGER NOT NULL PRIMARY KEY, ' . '[username] VARCHAR(50) UNIQUE NOT NULL, ' . '[password] VARCHAR(255) NULL, ' . '[real_name] VARCHAR(150) NULL)'; // Create the authentication credentials table $dbAdapter->query($sqlCreate); // Build a query to insert a row for which authentication may succeed $sqlInsert = \"INSERT INTO users (username, password, real_name) \" . \"VALUES ('my_username', 'my_password', 'My Real Name')\"; // Insert the data $dbAdapter->query($sqlInsert); As you add users, you will need to create a hash of the password provided and insert that into the database. For users on PHP 5.5+, you can use password_hash() : $hash = password_hash($password, PASSWORD_DEFAULT); Password hash length As of the time of writing, PHP uses a bcrypt algorithm by default for hashing passwords with password_hash() , and this produces 60 character strings. However, the default may change over time, and php.net recommends using 255 character fields for storage to allow for larger hash sizes in the future. To verify a password, we'll create a callback that uses password_verify() : $passwordValidation = function ($hash, $password) { return password_verify($password, $hash); }; Now that we have the database connection and a password validation function, we can create our Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter adapter instance, passing the options to the constructor or later via setter methods: use Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter as AuthAdapter; // Configure the instance with constructor parameters: $authAdapter = new AuthAdapter( $dbAdapter, 'users', 'username', 'password', $passwordValidation ); // Or configure the instance with setter methods: $authAdapter = new AuthAdapter($dbAdapter); $authAdapter ->setTableName('users') ->setIdentityColumn('username') ->setCredentialColumn('password') ->setCredentialValidationCallback($passwordValidation); At this point, the authentication adapter instance is ready to accept authentication queries. In order to formulate an authentication query, the input credential values are passed to the adapter prior to calling the authenticate() method: // Set the input credential values (e.g., from a login form): $authAdapter ->setIdentity('my_username') ->setCredential('my_password'); // Perform the authentication query, saving the result $result = $authAdapter->authenticate(); In addition to the availability of the getIdentity() method upon the authentication result object, Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter also supports retrieving the table row upon authentication success: // Print the identity: echo $result->getIdentity() . \"\\n\\n\"; // Print the result row: print_r($authAdapter->getResultRowObject()); /* Output: my_username Array ( [id] => 1 [username] => my_username [password] => my_password [real_name] => My Real Name ) */ Since the table row contains the credential value, it is important to secure the values against unintended access. When retrieving the result object, we can either specify what columns to return, or what columns to omit: // Specify the columns to return: $columnsToReturn = [ 'id', 'username', 'real_name', ]; print_r($authAdapter->getResultRowObject($columnsToReturn)); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ // Or specify the columns to omit; when using this approach, // pass a null value as the first argument to getResultRowObject(): $columnsToOmit = ['password']; print_r($authAdapter->getResultRowObject(null, $columnsToOmit); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ Advanced Usage While the basic use case will fit most scenarios, there may be cases where you have specialized needs, such as additional criteria that needs to be met for a user to match. Adding criteria to match Since the validation callback is only provided the hash value from the database and the credential provided by the user, you cannot do more complex matching within it. However, you can add criteria to the SQL sent to the server by retrieving the Zend\\Db\\Sql\\Select instance is uses. As an example, many websites require a user to activate their account before allowing them to login for the first time. We can add that criteria as follows: // Create a basic adapter $adapter = new AuthAdapter( $db, 'users', 'username', 'password', $passwordValidation ); // Now retrieve the Select instance and modify it: $select = $adapter->getDbSelect(); $select->where('active = \"TRUE\"'); // Authenticate; this will include \"users.active = TRUE\" in the WHERE clause: $adapter->authenticate();","title":"CallbackCheck"},{"location":"adapter/dbtable/callback-check/#callback-verification","text":"Some verification operations cannot be performed well on RDBMS servers. Other times, you may be unsure which RDBMS system you will be using long-term, and need to ensure authentication will work consistently. For these situations, you can use the Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter adapter. Similar to the CredentialTreatmentAdapter , it accepts a table name, identity column, and credential column; however, instead of a credential treatment, it accepts a credential validation callback that is executed when the database returns any matches, and which can be used to perform additional credential verifications.","title":"Callback Verification"},{"location":"adapter/dbtable/callback-check/#configuration-options","text":"The available configuration options include: tableName : This is the name of the database table that contains the authentication credentials, and against which the database authentication query is performed. identityColumn : This is the name of the database table column used to represent the identity. The identity column must contain unique values, such as a username or e-mail address. credentialColumn : This is the name of the database table column used to represent the credential. Under a simple identity and password authentication scheme, the credential value corresponds to the password. credentialValidationCallback : A PHP callable to execute when the database returns matches. The callback will receive: the value of the credentialColumn returned from the database the credential that was used by the adapter during authentication","title":"Configuration options"},{"location":"adapter/dbtable/callback-check/#basic-usage","text":"Many databases do not provide functions that implement a cryptographically secure hashing mechanism. Additionally, you may want to ensure that should you switch database systems, hashing is consistent. This is a perfect use case for the CallbackCheckAdapter adapter; you can implement the password hashing and verification within PHP instead. The following code creates an adapter for an in-memory database, creates a simple table schema, and inserts a row against which we can perform an authentication query later. This example requires the PDO SQLite extension to be available: use Zend\\Db\\Adapter\\Adapter as DbAdapter; // Create a SQLite database connection $dbAdapter = new DbAdapter([ 'driver' => 'Pdo_Sqlite', 'database' => 'data/sqlite.db', ]); // Build a simple table creation query $sqlCreate = 'CREATE TABLE [users] (' . '[id] INTEGER NOT NULL PRIMARY KEY, ' . '[username] VARCHAR(50) UNIQUE NOT NULL, ' . '[password] VARCHAR(255) NULL, ' . '[real_name] VARCHAR(150) NULL)'; // Create the authentication credentials table $dbAdapter->query($sqlCreate); // Build a query to insert a row for which authentication may succeed $sqlInsert = \"INSERT INTO users (username, password, real_name) \" . \"VALUES ('my_username', 'my_password', 'My Real Name')\"; // Insert the data $dbAdapter->query($sqlInsert); As you add users, you will need to create a hash of the password provided and insert that into the database. For users on PHP 5.5+, you can use password_hash() : $hash = password_hash($password, PASSWORD_DEFAULT);","title":"Basic Usage"},{"location":"adapter/dbtable/callback-check/#password-hash-length","text":"As of the time of writing, PHP uses a bcrypt algorithm by default for hashing passwords with password_hash() , and this produces 60 character strings. However, the default may change over time, and php.net recommends using 255 character fields for storage to allow for larger hash sizes in the future. To verify a password, we'll create a callback that uses password_verify() : $passwordValidation = function ($hash, $password) { return password_verify($password, $hash); }; Now that we have the database connection and a password validation function, we can create our Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter adapter instance, passing the options to the constructor or later via setter methods: use Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter as AuthAdapter; // Configure the instance with constructor parameters: $authAdapter = new AuthAdapter( $dbAdapter, 'users', 'username', 'password', $passwordValidation ); // Or configure the instance with setter methods: $authAdapter = new AuthAdapter($dbAdapter); $authAdapter ->setTableName('users') ->setIdentityColumn('username') ->setCredentialColumn('password') ->setCredentialValidationCallback($passwordValidation); At this point, the authentication adapter instance is ready to accept authentication queries. In order to formulate an authentication query, the input credential values are passed to the adapter prior to calling the authenticate() method: // Set the input credential values (e.g., from a login form): $authAdapter ->setIdentity('my_username') ->setCredential('my_password'); // Perform the authentication query, saving the result $result = $authAdapter->authenticate(); In addition to the availability of the getIdentity() method upon the authentication result object, Zend\\Authentication\\Adapter\\DbTable\\CallbackCheckAdapter also supports retrieving the table row upon authentication success: // Print the identity: echo $result->getIdentity() . \"\\n\\n\"; // Print the result row: print_r($authAdapter->getResultRowObject()); /* Output: my_username Array ( [id] => 1 [username] => my_username [password] => my_password [real_name] => My Real Name ) */ Since the table row contains the credential value, it is important to secure the values against unintended access. When retrieving the result object, we can either specify what columns to return, or what columns to omit: // Specify the columns to return: $columnsToReturn = [ 'id', 'username', 'real_name', ]; print_r($authAdapter->getResultRowObject($columnsToReturn)); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ // Or specify the columns to omit; when using this approach, // pass a null value as the first argument to getResultRowObject(): $columnsToOmit = ['password']; print_r($authAdapter->getResultRowObject(null, $columnsToOmit); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */","title":"Password hash length"},{"location":"adapter/dbtable/callback-check/#advanced-usage","text":"While the basic use case will fit most scenarios, there may be cases where you have specialized needs, such as additional criteria that needs to be met for a user to match.","title":"Advanced Usage"},{"location":"adapter/dbtable/callback-check/#adding-criteria-to-match","text":"Since the validation callback is only provided the hash value from the database and the credential provided by the user, you cannot do more complex matching within it. However, you can add criteria to the SQL sent to the server by retrieving the Zend\\Db\\Sql\\Select instance is uses. As an example, many websites require a user to activate their account before allowing them to login for the first time. We can add that criteria as follows: // Create a basic adapter $adapter = new AuthAdapter( $db, 'users', 'username', 'password', $passwordValidation ); // Now retrieve the Select instance and modify it: $select = $adapter->getDbSelect(); $select->where('active = \"TRUE\"'); // Authenticate; this will include \"users.active = TRUE\" in the WHERE clause: $adapter->authenticate();","title":"Adding criteria to match"},{"location":"adapter/dbtable/credential-treatment/","text":"DbTable Credential Treatment Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter will execute a SQL query containing the provided identity and credentials, passing the credentials to a credential treatment function defined on the RDBMS server; if an identity is returned, authentication succeeds. Credential treatments depends on your RDBMS, and while simple hashing function such as md5 and sha1 are generally available, it is recommended not to use them and rather use the RDBMS specific function such as PASSWORD(?) for MySQL or crypt() for PostgreSQL . More details are available in the next section. Security considerations Passing passwords to database in plaintext for insert or verification is generally not recommended. Sql statements can and usually are logged by the database, and passwords in them become visible to anyone with access to the logs or monitoring tools that consume those logs. The safer approach is to hash passwords, and to verify them against a stored hash in your application code. This way the password never leaves the application, and only the hashed value is exchanged with the database. As such, this adapter is not recommended for new applications, and existing applications should consider migrating to using PHP-provided password handling functions such as password_hash() and password_verify() . See CallbackCheckAdapter for more info. Configuration Options The available configuration options include: tableName : This is the name of the database table that contains the authentication credentials, and against which the database authentication query is performed. identityColumn : This is the name of the database table column used to represent the identity. The identity column must contain unique values, such as a username or e-mail address. credentialColumn : This is the name of the database table column used to represent the credential. Under a simple identity and password authentication scheme, the credential value corresponds to the password. See also the credentialTreatment option. credentialTreatment : In many cases, passwords and other sensitive data are encrypted, hashed, encoded, obscured, salted or otherwise treated through some function or algorithm. By specifying a parameterized treatment string with this method, such as ' PASSWORD(?) ', a developer may apply such arbitrary SQL upon input credential data. Since these functions are specific to the underlying RDBMS, check the database manual for the availability of such functions for your database system. Basic Usage As explained above, the Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter constructor requires an instance of Zend\\Db\\Adapter\\Adapter that serves as the database connection to which the authentication adapter instance is bound. First, the database connection should be created. The following code creates an adapter for an in-memory database, creates a simple table schema, and inserts a row against which we can perform an authentication query later. This example requires the PDO SQLite extension to be available: use Zend\\Db\\Adapter\\Adapter as DbAdapter; // Create a SQLite database connection $dbAdapter = new DbAdapter([ 'driver' => 'Pdo_Sqlite', 'database' => 'data/users.db', ]); // Build a simple table creation query $sqlCreate = 'CREATE TABLE [users] (' . '[id] INTEGER NOT NULL PRIMARY KEY, ' . '[username] VARCHAR(50) UNIQUE NOT NULL, ' . '[password] VARCHAR(32) NULL, ' . '[real_name] VARCHAR(150) NULL)'; // Create the authentication credentials table $dbAdapter->query($sqlCreate); // Build a query to insert a row for which authentication may succeed $sqlInsert = \"INSERT INTO users (username, password, real_name) \" . \"VALUES ('my_username', 'my_password', 'My Real Name')\"; // Insert the data $dbAdapter->query($sqlInsert); With the database connection and table data available, an instance of Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter may be created. Configuration option values may be passed to the constructor or deferred as parameters to setter methods after instantiation: use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // Configure the instance with constructor parameters: $authAdapter = new AuthAdapter( $dbAdapter, 'users', 'username', 'password' ); // Or configure the instance with setter methods: $authAdapter = new AuthAdapter($dbAdapter); $authAdapter ->setTableName('users') ->setIdentityColumn('username') ->setCredentialColumn('password'); At this point, the authentication adapter instance is ready to accept authentication queries. In order to formulate an authentication query, the input credential values are passed to the adapter prior to calling the authenticate() method: // Set the input credential values (e.g., from a login form): $authAdapter ->setIdentity('my_username') ->setCredential('my_password'); // Perform the authentication query, saving the result $result = $authAdapter->authenticate(); In addition to the availability of the getIdentity() method upon the authentication result object, Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter also supports retrieving the table row upon authentication success: // Print the identity: echo $result->getIdentity() . \"\\n\\n\"; // Print the result row: print_r($authAdapter->getResultRowObject()); /* Output: my_username Array ( [id] => 1 [username] => my_username [password] => my_password [real_name] => My Real Name ) */ Since the table row contains the credential value, it is important to secure the values against unintended access. When retrieving the result object, we can either specify what columns to return, or what columns to omit: // Specify the columns to return: $columnsToReturn = [ 'id', 'username', 'real_name', ]; print_r($authAdapter->getResultRowObject($columnsToReturn)); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ // Or specify the columns to omit; when using this approach, // pass a null value as the first argument to getResultRowObject(): $columnsToOmit = ['password']; print_r($authAdapter->getResultRowObject(null, $columnsToOmit); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ Advanced Usage While the primary purpose of zend-authentication is authentication and not authorization , there are a few instances and problems that toe the line between which domain they fit. Depending on how you've decided to explain your problem, it sometimes makes sense to solve what could look like an authorization problem within the authentication adapter. Below are a few examples showing how you can provide compound criteria to the credential treatment to solve more complex problems. Check for compromised user In this scenario, we use the credential treatment PASSWORD() , but also check to see that the user has not been flagged as \"compromised\", which is a potential value of the status field for the user record. use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // The status field value of an account is not equal to \"compromised\" $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?) AND status != \"compromised\"' ); Check for active user In this example, we check to see if a user is active; this may be necessary if we require a user to login once over X days, or if we need to ensure that they have followed a verification process. use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // The active field value of an account is equal to \"TRUE\" $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?) AND active = \"TRUE\"' ); Salting Another scenario can be the implementation of a salting mechanism. Salting refers to a technique for improving application security; it's based on the idea that concatenating a random string to every password makes it impossible to accomplish a successful brute force attack on the database using pre-computed hash values from a dictionary. Let's modify our table to store our salt string: $sqlAlter = \"ALTER TABLE [users] \" . \"ADD COLUMN [password_salt] \" . \"AFTER [password]\"; Salts should be created for each user using a cryptographically sound pseudo-random number generator (CSPRNG). PHP 7 provides an implementation via random_bytes() (and the random_compat package provides them for older, supported versions of PHP ): $salt = random_bytes(32); For earlier versions of PHP, use zend-math 's Zend\\Math\\Rand : use Zend\\Math\\Rand; $salt = Rand::getBytes(32, true); (As of zend-math 2.7.0, Rand::getBytes() will proxy to random_bytes() when running under PHP 7, making it a good, forwards-compatible solution for your application.) Do this each time you create a user or update their password, and store it in the password_salt column you created. Now let's build the adapter: $adapter = new AuthAdapter( $db, 'users', 'username', 'password', \"PASSWORD(CONCAT('staticSalt', ?, password_salt))\" ); Salt security You can improve security even more by using a static salt value hard coded into your application. In the case that your database is compromised (e.g. by an SQL injection attack) but your web server is intact, your data is still unusable for the attacker. Define the salt as an environment variable on your web server, and then either pull it from the environment, or assign it to a constant during bootstrap; pass the value to the credential treatment when creating your adapter. The above example uses the value \"staticSalt\"; you should create a better salt using one of the methods outlined above. Alter the SQL select directly Another alternative is to use the getDbSelect() method to retrieve the Zend\\Db\\Sql\\Select instance associated with the adapter and modify it. (The method is common to all Zend\\Authentication\\Adapter\\DbTable adapters.) The Select instance is consumed by the authenticate() routine when building the SQL to execute on the RDBMS server. It is important to note that this method will always return the same Select instance regardless if authenticate() has been called or not; identity and credential values are passed to the instance as placeholders. This approach allows you to define a generic credential treatment, and then add criteria later, potentially based on specific paths through the application. The following uses the second example in this section, adding another WHERE clause to determine if the user is active in the system. // Create a basic adapter, with only an PASSWORD() credential treatment: $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?)' ); // Now retrieve the Select instance and modify it: $select = $adapter->getDbSelect(); $select->where('active = \"TRUE\"'); // Authenticate; this will include \"users.active = TRUE\" in the WHERE clause: $adapter->authenticate();","title":"CredentialTreatmentAdapter"},{"location":"adapter/dbtable/credential-treatment/#dbtable-credential-treatment","text":"Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter will execute a SQL query containing the provided identity and credentials, passing the credentials to a credential treatment function defined on the RDBMS server; if an identity is returned, authentication succeeds. Credential treatments depends on your RDBMS, and while simple hashing function such as md5 and sha1 are generally available, it is recommended not to use them and rather use the RDBMS specific function such as PASSWORD(?) for MySQL or crypt() for PostgreSQL . More details are available in the next section.","title":"DbTable Credential Treatment"},{"location":"adapter/dbtable/credential-treatment/#security-considerations","text":"Passing passwords to database in plaintext for insert or verification is generally not recommended. Sql statements can and usually are logged by the database, and passwords in them become visible to anyone with access to the logs or monitoring tools that consume those logs. The safer approach is to hash passwords, and to verify them against a stored hash in your application code. This way the password never leaves the application, and only the hashed value is exchanged with the database. As such, this adapter is not recommended for new applications, and existing applications should consider migrating to using PHP-provided password handling functions such as password_hash() and password_verify() . See CallbackCheckAdapter for more info.","title":"Security considerations"},{"location":"adapter/dbtable/credential-treatment/#configuration-options","text":"The available configuration options include: tableName : This is the name of the database table that contains the authentication credentials, and against which the database authentication query is performed. identityColumn : This is the name of the database table column used to represent the identity. The identity column must contain unique values, such as a username or e-mail address. credentialColumn : This is the name of the database table column used to represent the credential. Under a simple identity and password authentication scheme, the credential value corresponds to the password. See also the credentialTreatment option. credentialTreatment : In many cases, passwords and other sensitive data are encrypted, hashed, encoded, obscured, salted or otherwise treated through some function or algorithm. By specifying a parameterized treatment string with this method, such as ' PASSWORD(?) ', a developer may apply such arbitrary SQL upon input credential data. Since these functions are specific to the underlying RDBMS, check the database manual for the availability of such functions for your database system.","title":"Configuration Options"},{"location":"adapter/dbtable/credential-treatment/#basic-usage","text":"As explained above, the Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter constructor requires an instance of Zend\\Db\\Adapter\\Adapter that serves as the database connection to which the authentication adapter instance is bound. First, the database connection should be created. The following code creates an adapter for an in-memory database, creates a simple table schema, and inserts a row against which we can perform an authentication query later. This example requires the PDO SQLite extension to be available: use Zend\\Db\\Adapter\\Adapter as DbAdapter; // Create a SQLite database connection $dbAdapter = new DbAdapter([ 'driver' => 'Pdo_Sqlite', 'database' => 'data/users.db', ]); // Build a simple table creation query $sqlCreate = 'CREATE TABLE [users] (' . '[id] INTEGER NOT NULL PRIMARY KEY, ' . '[username] VARCHAR(50) UNIQUE NOT NULL, ' . '[password] VARCHAR(32) NULL, ' . '[real_name] VARCHAR(150) NULL)'; // Create the authentication credentials table $dbAdapter->query($sqlCreate); // Build a query to insert a row for which authentication may succeed $sqlInsert = \"INSERT INTO users (username, password, real_name) \" . \"VALUES ('my_username', 'my_password', 'My Real Name')\"; // Insert the data $dbAdapter->query($sqlInsert); With the database connection and table data available, an instance of Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter may be created. Configuration option values may be passed to the constructor or deferred as parameters to setter methods after instantiation: use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // Configure the instance with constructor parameters: $authAdapter = new AuthAdapter( $dbAdapter, 'users', 'username', 'password' ); // Or configure the instance with setter methods: $authAdapter = new AuthAdapter($dbAdapter); $authAdapter ->setTableName('users') ->setIdentityColumn('username') ->setCredentialColumn('password'); At this point, the authentication adapter instance is ready to accept authentication queries. In order to formulate an authentication query, the input credential values are passed to the adapter prior to calling the authenticate() method: // Set the input credential values (e.g., from a login form): $authAdapter ->setIdentity('my_username') ->setCredential('my_password'); // Perform the authentication query, saving the result $result = $authAdapter->authenticate(); In addition to the availability of the getIdentity() method upon the authentication result object, Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter also supports retrieving the table row upon authentication success: // Print the identity: echo $result->getIdentity() . \"\\n\\n\"; // Print the result row: print_r($authAdapter->getResultRowObject()); /* Output: my_username Array ( [id] => 1 [username] => my_username [password] => my_password [real_name] => My Real Name ) */ Since the table row contains the credential value, it is important to secure the values against unintended access. When retrieving the result object, we can either specify what columns to return, or what columns to omit: // Specify the columns to return: $columnsToReturn = [ 'id', 'username', 'real_name', ]; print_r($authAdapter->getResultRowObject($columnsToReturn)); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */ // Or specify the columns to omit; when using this approach, // pass a null value as the first argument to getResultRowObject(): $columnsToOmit = ['password']; print_r($authAdapter->getResultRowObject(null, $columnsToOmit); /* Output: Array ( [id] => 1 [username] => my_username [real_name] => My Real Name ) */","title":"Basic Usage"},{"location":"adapter/dbtable/credential-treatment/#advanced-usage","text":"While the primary purpose of zend-authentication is authentication and not authorization , there are a few instances and problems that toe the line between which domain they fit. Depending on how you've decided to explain your problem, it sometimes makes sense to solve what could look like an authorization problem within the authentication adapter. Below are a few examples showing how you can provide compound criteria to the credential treatment to solve more complex problems.","title":"Advanced Usage"},{"location":"adapter/dbtable/credential-treatment/#check-for-compromised-user","text":"In this scenario, we use the credential treatment PASSWORD() , but also check to see that the user has not been flagged as \"compromised\", which is a potential value of the status field for the user record. use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // The status field value of an account is not equal to \"compromised\" $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?) AND status != \"compromised\"' );","title":"Check for compromised user"},{"location":"adapter/dbtable/credential-treatment/#check-for-active-user","text":"In this example, we check to see if a user is active; this may be necessary if we require a user to login once over X days, or if we need to ensure that they have followed a verification process. use Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter as AuthAdapter; // The active field value of an account is equal to \"TRUE\" $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?) AND active = \"TRUE\"' );","title":"Check for active user"},{"location":"adapter/dbtable/credential-treatment/#salting","text":"Another scenario can be the implementation of a salting mechanism. Salting refers to a technique for improving application security; it's based on the idea that concatenating a random string to every password makes it impossible to accomplish a successful brute force attack on the database using pre-computed hash values from a dictionary. Let's modify our table to store our salt string: $sqlAlter = \"ALTER TABLE [users] \" . \"ADD COLUMN [password_salt] \" . \"AFTER [password]\"; Salts should be created for each user using a cryptographically sound pseudo-random number generator (CSPRNG). PHP 7 provides an implementation via random_bytes() (and the random_compat package provides them for older, supported versions of PHP ): $salt = random_bytes(32); For earlier versions of PHP, use zend-math 's Zend\\Math\\Rand : use Zend\\Math\\Rand; $salt = Rand::getBytes(32, true); (As of zend-math 2.7.0, Rand::getBytes() will proxy to random_bytes() when running under PHP 7, making it a good, forwards-compatible solution for your application.) Do this each time you create a user or update their password, and store it in the password_salt column you created. Now let's build the adapter: $adapter = new AuthAdapter( $db, 'users', 'username', 'password', \"PASSWORD(CONCAT('staticSalt', ?, password_salt))\" );","title":"Salting"},{"location":"adapter/dbtable/credential-treatment/#salt-security","text":"You can improve security even more by using a static salt value hard coded into your application. In the case that your database is compromised (e.g. by an SQL injection attack) but your web server is intact, your data is still unusable for the attacker. Define the salt as an environment variable on your web server, and then either pull it from the environment, or assign it to a constant during bootstrap; pass the value to the credential treatment when creating your adapter. The above example uses the value \"staticSalt\"; you should create a better salt using one of the methods outlined above.","title":"Salt security"},{"location":"adapter/dbtable/credential-treatment/#alter-the-sql-select-directly","text":"Another alternative is to use the getDbSelect() method to retrieve the Zend\\Db\\Sql\\Select instance associated with the adapter and modify it. (The method is common to all Zend\\Authentication\\Adapter\\DbTable adapters.) The Select instance is consumed by the authenticate() routine when building the SQL to execute on the RDBMS server. It is important to note that this method will always return the same Select instance regardless if authenticate() has been called or not; identity and credential values are passed to the instance as placeholders. This approach allows you to define a generic credential treatment, and then add criteria later, potentially based on specific paths through the application. The following uses the second example in this section, adding another WHERE clause to determine if the user is active in the system. // Create a basic adapter, with only an PASSWORD() credential treatment: $adapter = new AuthAdapter( $db, 'users', 'username', 'password', 'PASSWORD(?)' ); // Now retrieve the Select instance and modify it: $select = $adapter->getDbSelect(); $select->where('active = \"TRUE\"'); // Authenticate; this will include \"users.active = TRUE\" in the WHERE clause: $adapter->authenticate();","title":"Alter the SQL select directly"},{"location":"adapter/dbtable/intro/","text":"Database Table Authentication The adapters under the Zend\\Authentication\\Adapter\\DbTable provide the ability to authenticate against credentials stored in a database table, with two approaches possible: usage of a credential treatment function on the RDBMS server with the provided credentials. execution of a PHP callback on the identity returned by the RDBMS server. Because each adapter requires an instance of Zend\\Db\\Adapter\\Adapter to be passed to its constructor, each instance is bound to a particular database connection. Other configuration options may be set through the constructor and through instance methods, one for each option. Zend\\Authentication\\Adapter\\DbTable class is deprecated The concrete adapter Zend\\Authentication\\Adapter\\DbTable has been deprecated since 2.2.0, and its responsibilities have been split into two, Zend\\Authentication\\Adapter\\DbTable\\CallbackCheck and Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter . If you were using Zend\\Authentication\\Adapter\\DbTable previously, you can replace its usage with Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter , as the APIs are the same; DbTable extends CredentialTreatmentAdapter at this time.","title":"Intro"},{"location":"adapter/dbtable/intro/#database-table-authentication","text":"The adapters under the Zend\\Authentication\\Adapter\\DbTable provide the ability to authenticate against credentials stored in a database table, with two approaches possible: usage of a credential treatment function on the RDBMS server with the provided credentials. execution of a PHP callback on the identity returned by the RDBMS server. Because each adapter requires an instance of Zend\\Db\\Adapter\\Adapter to be passed to its constructor, each instance is bound to a particular database connection. Other configuration options may be set through the constructor and through instance methods, one for each option.","title":"Database Table Authentication"},{"location":"adapter/dbtable/intro/#zendauthenticationadapterdbtable-class-is-deprecated","text":"The concrete adapter Zend\\Authentication\\Adapter\\DbTable has been deprecated since 2.2.0, and its responsibilities have been split into two, Zend\\Authentication\\Adapter\\DbTable\\CallbackCheck and Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter . If you were using Zend\\Authentication\\Adapter\\DbTable previously, you can replace its usage with Zend\\Authentication\\Adapter\\DbTable\\CredentialTreatmentAdapter , as the APIs are the same; DbTable extends CredentialTreatmentAdapter at this time.","title":"Zend\\Authentication\\Adapter\\DbTable class is deprecated"}]}